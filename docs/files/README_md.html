<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>README.md</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>README.md
</h1>
<div class='paths'>
README.md
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2021-01-10 22:09:34 -0800</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<h1 id="label-LilBlaster"><a href="../classes/LilBlaster.html">LilBlaster</a><span><a href="#label-LilBlaster">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="../classes/LilBlaster.html">LilBlaster</a> is a gem for
interacting with IR Transmitters and Receivers on the Raspberry Pi. It
includes functionality to send, receive, identify, and catalog
transmissions, with a particular penchant for handling IR Remote control
codes.</p>

<h2 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Add this line to your application&#39;s Gemfile:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&#39;lil_blaster&#39;</span>, <span class="ruby-value">github:</span> <span class="ruby-string">&#39;jtp184/lil_blaster&#39;</span></pre>

<p>You can also download and install it globally with</p>

<pre>git clone https://github.com/jtp184/lil_blaster&#x000A;cd lil_blaster&#x000A;rake install</pre>

<p>For help setting up your pi for use with this gem, check out the <a
href="https://github.com/jtp184/lil_blaster/blob/master/RASPI_SETUP.md">RASPI_SETUP</a>
instructions</p>

<h2 id="label-Hardware">Hardware<span><a href="#label-Hardware">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This gem was developed using a generically available <a
href="http://raspberrypiwiki.com/Raspberry_Pi_IR_Control_Expansion_Board">IR
Expansion Board</a> on the Raspberry Pi 3+, and various remotes including
the Samsung BN59-01006A.</p>

<h2 id="label-LIRC">LIRC<span><a href="#label-LIRC">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>This gem tries for basic interoperability with the <a
href="https://www.lirc.org/">Linux Infrared Remote Control</a> project. You
can search for remote configurations on the <a
href="http://lirc-remotes.sourceforge.net/remotes-table.html">LIRC
Database</a>, and copy them into the codexes directory right alongside
codexes created with this gem. Currently supported are shift and space
encoded, raw, and RCMM remote definitions. Many options, but not all are
implemented, so feel free to open an <a
href="https://github.com/jtp184/lil_blaster/issues/new">issue</a> if
you&#39;d like to see a LIRC feature supported that currently isn&#39;t.</p>

<h2 id="label-CLI">CLI<span><a href="#label-CLI">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="../classes/LilBlaster.html">LilBlaster</a> comes with a command
line program to enable sending, receiving, identifying, and cataloging the
IR transmissions from devices. This allows you to quickly get started
cloning your own remotes, and replacing them with the Pi.</p>

<h3 id="label-config"><code>config</code><span><a href="#label-config">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can use the config subcommand to view and set configuration options,
which will then be accessible by the library for defaults. Most important
are the keys for <code>:codexes_dir</code> and <code>:default_codex</code>,
which are used to set the name of the directory to load and save codexes
to, and the name of the default codex to load.</p>

<pre># Get all config options&#x000A;lil_blaster config --get&#x000A;# =&gt;&#x000A;# default_codex =&gt; samsung&#x000A;# default_code =&gt; power&#x000A;# Or just one&#x000A;lil_blaster config --get default_codex&#x000A;# default_codex =&gt; samsung&#x000A;&#x000A;# Set options&#x000A;lil_blaster config --set codexes_dir /path/to/directory&#x000A;# default_codex =&gt; /path/to/directory&#x000A;&#x000A;# Unset them&#x000A;lil_blaster config --unset default_codex&#x000A;# default_codex =&gt; nil&#x000A;&#x000A;# You can also set values interactively&#x000A;lil_blaster config --interactive</pre>

<h3 id="label-send_code"><code>send_code</code><span><a href="#label-send_code">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When codexes are available, the send_code command will generate and send a
transmission based on the passed symbol.</p>

<pre># By default, sends the value of ConfigFile[:default_code]&#x000A;lil_blaster send_code&#x000A;# And uses the default codex for passed symbols&#x000A;lil_blaster send_code power&#x000A;&#x000A;# You can override codex choice with a filepath, or a codex name&#x000A;lil_blaster send_code power --codex television&#x000A;lil_blaster send_code power -c /path/to/new/codex&#x000A;&#x000A;# Send multiple instances of a code or code sequence&#x000A;lil_blaster send_code volume_up --times 4</pre>

<h3 id="label-learn"><code>learn</code><span><a href="#label-learn">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Adding new code listings is easiest accomplished by pointing the device at
the Raspberry Pi and running the <code>learn</code> command. Provide a
codex name, and keys to learn. A new codex will ask you to identify the
protocol with a precursor session, then launch into learning the new codes.</p>

<pre>lil_blaster learn --codex television --keys power volume_up volume_down input</pre>
<!-- Image of learn codex -->
<p><img
src="https://justinp-io-production.s3.amazonaws.com/store/d5b422e716f920ccef8e7945760ca924.png"></p>

<p>When run interactively, you can choose from some default options for keys,
as well as select an existing codex from a drop down. Codexes are saved and
loaded to the codexes directory defined by the config file.</p>
<!-- Image of learn interactively -->
<p><img
src="https://justinp-io-production.s3.amazonaws.com/store/92cc12bc61da46e24739f697a790cde6.png"></p>

<h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>

<h3 id="label-Documentation">Documentation<span><a href="#label-Documentation">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>All methods and classes are RDoc documented at <a
href="https://jtp184.github.io/lil_blaster">jtp184.github.io/lil_blaster</a></p>

<h3 id="label-Transmissions">Transmissions<span><a href="#label-Transmissions">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A <code>Transmission</code> wraps a collection of pulse timings, with
methods to help analyze them</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = [<span class="ruby-value">500</span>, <span class="ruby-value">1000</span>, <span class="ruby-value">600</span>, <span class="ruby-value">2000</span>]&#x000A;&#x000A;<span class="ruby-identifier">t1</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">data:</span> <span class="ruby-identifier">d</span>)&#x000A;&#x000A;<span class="ruby-comment"># You can optionally specify a carrier wave frequency in kHz,</span>&#x000A;<span class="ruby-comment"># with 38.0 being the default</span>&#x000A;<span class="ruby-identifier">t2</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">data:</span> <span class="ruby-identifier">d</span>, <span class="ruby-value">carrier_wave:</span> <span class="ruby-value">44.0</span>)&#x000A;&#x000A;<span class="ruby-comment"># Transmissions can return their count, the number of pulses</span>&#x000A;<span class="ruby-identifier">t1</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 4</span>&#x000A;<span class="ruby-comment"># As well as their length in micros</span>&#x000A;<span class="ruby-identifier">t2</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 4100</span>&#x000A;&#x000A;<span class="ruby-comment"># Transmissions can be split into mark/spaces with #tuples</span>&#x000A;<span class="ruby-identifier">t1</span>.<span class="ruby-identifier">tuples</span> <span class="ruby-comment"># =&gt; [[500, 1000],[600, 2000]]</span>&#x000A;&#x000A;<span class="ruby-comment"># Mathematical operators are implemented to simplify transformation</span>&#x000A;&#x000A;<span class="ruby-comment"># Add two Transmissions to combine their data</span>&#x000A;<span class="ruby-identifier">t3</span> = <span class="ruby-identifier">t1</span> <span class="ruby-operator">+</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">data:</span> [<span class="ruby-value">700</span>, <span class="ruby-value">4000</span>, <span class="ruby-value">800</span>, <span class="ruby-value">8000</span>])&#x000A;<span class="ruby-identifier">t3</span>.<span class="ruby-identifier">tuples</span> <span class="ruby-comment"># =&gt; [[500, 1000],[600, 2000],[700, 4000],[800, 8000]]</span>&#x000A;&#x000A;<span class="ruby-comment"># Multiply a Transmission by an integer to repeat its data</span>&#x000A;<span class="ruby-identifier">t4</span> = <span class="ruby-identifier">t3</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>&#x000A;<span class="ruby-identifier">t4</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 24</span></pre>

<h3 id="label-Protocols">Protocols<span><a href="#label-Protocols">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="label-Base+Protocol">Base Protocol<span><a href="#label-Base+Protocol">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>Protocol</code> module collects different protocol
implementations, which are subclasses of the <code>BaseProtocol</code>
class. The module itself serves as an interface for matching transmissions
to those protocols.</p>

<pre class="ruby"><span class="ruby-comment"># A Transmission in RC5 format</span>&#x000A;<span class="ruby-identifier">pulses</span> = [&#x000A;  <span class="ruby-value">4511</span>, <span class="ruby-value">4540</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">609</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>,&#x000A;  <span class="ruby-value">517</span>, <span class="ruby-value">1732</span>, <span class="ruby-value">517</span>, <span class="ruby-value">47_312</span>&#x000A;]&#x000A;&#x000A;<span class="ruby-identifier">tr1</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">data:</span> <span class="ruby-identifier">pulses</span>)&#x000A;&#x000A;<span class="ruby-comment"># Determine protocol from the data and return a symbol</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span>.<span class="ruby-identifier">identify</span>(<span class="ruby-identifier">tr1</span>) <span class="ruby-comment"># =&gt; :Manchester</span>&#x000A;&#x000A;<span class="ruby-comment"># Or directly decode with #identify!</span>&#x000A;<span class="ruby-identifier">protocol</span>, <span class="ruby-identifier">command</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span>.<span class="ruby-identifier">identify!</span>(<span class="ruby-identifier">tr1</span>)&#x000A;&#x000A;<span class="ruby-identifier">protocol</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; LilBlaster::Protocol::Manchester</span>&#x000A;<span class="ruby-identifier">protocol</span>.<span class="ruby-identifier">pulse_values</span> <span class="ruby-comment"># =&gt; {</span>&#x000A;                      <span class="ruby-comment">#      :header =&gt; [4511, 4540],</span>&#x000A;                      <span class="ruby-comment">#      :zero =&gt; [517, 609],</span>&#x000A;                      <span class="ruby-comment">#      :one =&gt; [517, 1732]</span>&#x000A;                      <span class="ruby-comment">#    }</span>&#x000A;&#x000A;<span class="ruby-identifier">command</span>.<span class="ruby-identifier">to_s</span>(<span class="ruby-value">16</span>) <span class="ruby-comment"># =&gt; &quot;40bf&quot;</span>&#x000A;&#x000A;<span class="ruby-comment"># Once a protocol is derived, you can encode data using it</span>&#x000A;<span class="ruby-identifier">tr2</span> = <span class="ruby-identifier">protocol</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-identifier">command</span>)&#x000A;<span class="ruby-identifier">tr1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">tr2</span> <span class="ruby-comment"># =&gt; true</span>&#x000A;&#x000A;<span class="ruby-comment"># Or get a string representation</span>&#x000A;<span class="ruby-identifier">protocol</span>.<span class="ruby-identifier">to_bytestring</span>(<span class="ruby-identifier">command</span>) <span class="ruby-comment"># =&gt; &quot;11100000111000000100000010111111&quot;</span></pre>

<h4 id="label-Manchester+Protocol">Manchester Protocol<span><a href="#label-Manchester+Protocol">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>Manchester</code> protocol class handles both <a
href="https://www.sbprojects.net/knowledge/ir/rc5.php">RC5</a> and <a
href="https://www.sbprojects.net/knowledge/ir/nec.php">NEC</a> remotes.</p>

<pre class="ruby"><span class="ruby-comment"># Manchester transmissions have a header, and 2 bit data with post_bit and a gap</span>&#x000A;<span class="ruby-comment"># It also often includes a precursor data burst</span>&#x000A;<span class="ruby-identifier">props</span> = {&#x000A;  <span class="ruby-value">system_data:</span> <span class="ruby-value">0xE0E0</span>,&#x000A;  <span class="ruby-value">pulse_values:</span> {&#x000A;    <span class="ruby-value">header:</span> [<span class="ruby-value">4511</span>, <span class="ruby-value">4540</span>],&#x000A;    <span class="ruby-value">zero:</span> [<span class="ruby-value">517</span>, <span class="ruby-value">1732</span>],&#x000A;    <span class="ruby-value">one:</span> [<span class="ruby-value">517</span>, <span class="ruby-value">609</span>]&#x000A;  },&#x000A;  <span class="ruby-value">post_bit:</span> <span class="ruby-value">517</span>,&#x000A;  <span class="ruby-value">gap:</span> <span class="ruby-value">47_312</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-identifier">pr</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span><span class="ruby-operator">::</span><span class="ruby-constant">Manchester</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">props</span>)&#x000A;&#x000A;<span class="ruby-identifier">pr</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">0x40BF</span>) <span class="ruby-comment"># =&gt; &lt;LilBlaster::Transmission...&gt;</span></pre>

<h4 id="label-RCMM+Protocol">RCMM Protocol<span><a href="#label-RCMM+Protocol">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>The <code>RCMM</code> protocol class handles <a
href="https://www.sbprojects.net/knowledge/ir/nec.php">RCMM</a>
transmissions, with 4-bit data transmissions.</p>

<pre class="ruby"><span class="ruby-identifier">props</span> = {&#x000A;  <span class="ruby-value">pulse_values:</span> {&#x000A;    <span class="ruby-value">header:</span> [<span class="ruby-value">480</span>,<span class="ruby-value">228</span>],&#x000A;    <span class="ruby-value">zero:</span> [<span class="ruby-value">216</span>, <span class="ruby-value">228</span>],&#x000A;    <span class="ruby-value">one:</span> [<span class="ruby-value">216</span>, <span class="ruby-value">395</span>],&#x000A;    <span class="ruby-value">two:</span> [<span class="ruby-value">216</span>, <span class="ruby-value">559</span>],&#x000A;    <span class="ruby-value">three:</span> [<span class="ruby-value">216</span>, <span class="ruby-value">726</span>],&#x000A;  },&#x000A;  <span class="ruby-value">pre_data:</span> <span class="ruby-value">8</span>,&#x000A;  <span class="ruby-value">post_bit:</span> <span class="ruby-value">216</span>,&#x000A;  <span class="ruby-value">gap:</span> <span class="ruby-value">27_497</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-identifier">pr</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span><span class="ruby-operator">::</span><span class="ruby-constant">RCMM</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">props</span>)&#x000A;&#x000A;<span class="ruby-identifier">pr</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">0x1</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">pr</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">0x81</span>)</pre>

<h3 id="label-Codexes">Codexes<span><a href="#label-Codexes">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>Codex</code> class provides a way to collect codes that use the
same protocol, allowing the organizing and sharing of codes for devices.</p>

<pre class="ruby"><span class="ruby-comment"># Creating a codex without a protocol</span>&#x000A;<span class="ruby-identifier">codex</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">remote_name:</span> <span class="ruby-string">&#39;example&#39;</span>)&#x000A;&#x000A;<span class="ruby-comment"># You can manually specify a protocol by passing in arguments</span>&#x000A;<span class="ruby-identifier">proto_sym</span> = <span class="ruby-value">:Manchester</span>&#x000A;<span class="ruby-identifier">proto_opts</span> = {&#x000A;  <span class="ruby-value">pulse_values:</span> {&#x000A;    <span class="ruby-value">header:</span> [<span class="ruby-value">4511</span>, <span class="ruby-value">4540</span>],&#x000A;    <span class="ruby-value">zero:</span> [<span class="ruby-value">517</span>, <span class="ruby-value">609</span>],&#x000A;    <span class="ruby-value">one:</span> [<span class="ruby-value">517</span>, <span class="ruby-value">1732</span>]&#x000A;  },&#x000A;  <span class="ruby-value">gap:</span> <span class="ruby-value">47_312</span>,&#x000A;  <span class="ruby-value">system_data:</span> <span class="ruby-value">57_568</span>&#x000A;}&#x000A;&#x000A;<span class="ruby-identifier">codex</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">remote_name:</span> <span class="ruby-string">&#39;example&#39;</span>,&#x000A;  <span class="ruby-value">protocol:</span> <span class="ruby-identifier">proto_sym</span>,&#x000A;  <span class="ruby-value">protocol_options:</span> <span class="ruby-identifier">proto_opts</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-comment"># Or directly passing an instance</span>&#x000A;<span class="ruby-identifier">proto_obj</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span>[<span class="ruby-identifier">proto_sym</span>].<span class="ruby-identifier">new</span>(<span class="ruby-identifier">proto_opts</span>)&#x000A;<span class="ruby-identifier">codex</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">remote_name:</span> <span class="ruby-string">&#39;example&#39;</span>,&#x000A;  <span class="ruby-value">protocol:</span> <span class="ruby-identifier">proto_obj</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-comment"># Codes can be added directly</span>&#x000A;<span class="ruby-identifier">codex</span>[<span class="ruby-value">:power</span>] = <span class="ruby-value">16_575</span>&#x000A;&#x000A;<span class="ruby-comment"># Or by using the #append method, which accepts multiple data formats</span>&#x000A;&#x000A;<span class="ruby-identifier">raw</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(&#x000A;  <span class="ruby-value">data:</span> [<span class="ruby-value">39</span>, <span class="ruby-value">325</span>, <span class="ruby-value">1128</span>, <span class="ruby-value">203</span>, <span class="ruby-value">159</span>, <span class="ruby-value">324</span>, <span class="ruby-value">39</span>, <span class="ruby-value">39</span>]&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">append</span>(<span class="ruby-value">transmission:</span> <span class="ruby-identifier">proto_obj</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">57_375</span>), <span class="ruby-value">as:</span> <span class="ruby-value">:volume_up</span>)&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">append</span>(<span class="ruby-value">data:</span> <span class="ruby-value">14_025</span>, <span class="ruby-value">key:</span> <span class="ruby-value">:red</span>)&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">append</span>(<span class="ruby-value">raw_transmission:</span> <span class="ruby-identifier">raw</span>, <span class="ruby-value">name:</span> <span class="ruby-value">:b1</span>)&#x000A;&#x000A;<span class="ruby-comment"># Using #append can also automatically infer a protocol from a transmission</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">new</span>&#x000A;                 .<span class="ruby-identifier">append</span>(<span class="ruby-value">transmission:</span> <span class="ruby-identifier">proto_obj</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">53_805</span>))&#x000A;                 .<span class="ruby-identifier">protocol</span>&#x000A;                 .<span class="ruby-identifier">nil?</span> <span class="ruby-comment"># =&gt; false</span>&#x000A;&#x000A;<span class="ruby-comment"># Or manually apply / overwrite one</span>&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">append</span>(&#x000A;  <span class="ruby-value">transmission:</span> <span class="ruby-identifier">proto_obj</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-value">2295</span>),&#x000A;  <span class="ruby-value">as:</span> <span class="ruby-value">:channel_down</span>,&#x000A;  <span class="ruby-value">replace_protocol:</span> <span class="ruby-keyword">true</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-comment"># An array value implies sending both codes</span>&#x000A;<span class="ruby-identifier">codex</span>[<span class="ruby-value">:twofer</span>] = [<span class="ruby-value">4096</span>, <span class="ruby-value">4112</span>]&#x000A;&#x000A;<span class="ruby-comment"># To generate transmissions, pass the corresponding key to #call,</span>&#x000A;<span class="ruby-comment"># values in codes will be handled based on type</span>&#x000A;&#x000A;<span class="ruby-comment"># Transmissions are returned directly</span>&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:b1</span>).<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; LilBlaster::Transmission</span>&#x000A;<span class="ruby-comment"># Arrays are turned into Transmissions which are then joined</span>&#x000A;<span class="ruby-identifier">codex</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:twofer</span>).<span class="ruby-identifier">count</span> <span class="ruby-operator">==</span> (<span class="ruby-identifier">codex</span>.(<span class="ruby-identifier">power</span>).<span class="ruby-identifier">length</span> <span class="ruby-operator">*</span> <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; true</span>&#x000A;<span class="ruby-comment"># Others are passed to the protocol to encode and the result returned</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Protocol</span><span class="ruby-operator">::</span><span class="ruby-constant">Manchester</span>.<span class="ruby-identifier">same_data?</span>(&#x000A;  <span class="ruby-identifier">codex</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:power</span>),&#x000A;  <span class="ruby-identifier">proto_obj</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-identifier">codex</span>[<span class="ruby-value">:power</span>])&#x000A;) <span class="ruby-comment"># =&gt; true</span></pre>

<p>Also on this class are functions for saving, loading, and automatic loading
of codexes based on configured values. Codexes saved in the codexes
directory can be autoloaded by the gem.</p>

<pre class="ruby"><span class="ruby-comment"># Codexes can be loaded from a filepath, and saved out again</span>&#x000A;<span class="ruby-identifier">c1</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">load</span>(<span class="ruby-string">&#39;/path/on/system/example_codex.yml&#39;</span>)&#x000A;<span class="ruby-identifier">c1</span>.<span class="ruby-identifier">save_file</span> <span class="ruby-comment"># =&gt; &lt;File:/path/on/system/example_codex.yml (closed)&gt;</span>&#x000A;&#x000A;<span class="ruby-comment"># Codexes can be passed in as a YAML string and exported to one as well</span>&#x000A;<span class="ruby-identifier">c2</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">from_yaml</span>(<span class="ruby-operator">...</span>)&#x000A;<span class="ruby-identifier">c2</span>.<span class="ruby-identifier">to_yaml</span> <span class="ruby-comment"># =&gt; &quot;---\n...&quot;</span>&#x000A;&#x000A;<span class="ruby-comment"># Autoload based on the value set in ConfigFile for :codexes_dir</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">autoload</span> <span class="ruby-comment"># =&gt; [&lt;LilBlaster::Codex...&gt;,...]</span>&#x000A;&#x000A;<span class="ruby-comment"># Return a specific default codex based on the value set in ConfigFile</span>&#x000A;<span class="ruby-identifier">c3</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">default</span>&#x000A;<span class="ruby-identifier">c3</span>.<span class="ruby-identifier">remote_name</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-constant">ConfigFile</span>[<span class="ruby-value">:default_codex</span>]) <span class="ruby-comment"># =&gt; true</span></pre>

<h3 id="label-Reader">Reader<span><a href="#label-Reader">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Capturing transmissions is done with the <code>Reader</code> class, which
handles interacting with the IR Receiver. At its most basic, you can block
and record for a number of seconds or captured transmissions.</p>

<pre class="ruby"><span class="ruby-comment"># Everything captured in 4 seconds (including potential partials)</span>&#x000A;<span class="ruby-identifier">captures</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">record</span>(<span class="ruby-value">seconds:</span> <span class="ruby-value">4</span>)&#x000A;&#x000A;<span class="ruby-comment"># Capture whole transmissions, splitting on the gaps</span>&#x000A;<span class="ruby-identifier">captures</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">record</span>(<span class="ruby-value">first:</span> <span class="ruby-value">4</span>)</pre>

<p>There are also functions for asynchronous polling, where captured
transmissions are dumped into a buffer on the reader class. They can also
optionally be yielded to observer objects, either raw or cooked.</p>

<pre class="ruby"><span class="ruby-comment"># Begin scanning with #continuous_scan</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">continuous_scan</span>&#x000A;&#x000A;<span class="ruby-comment"># Internally, transmissions remain stored in a buffer as they come in</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">transmission_buffer</span>.<span class="ruby-identifier">count</span> <span class="ruby-comment"># =&gt; 8</span>&#x000A;&#x000A;<span class="ruby-comment"># Stop the scan with #stop_scan</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">stop_scan</span>&#x000A;&#x000A;<span class="ruby-comment"># You can also attach observers to the reader</span>&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">Watcher</span>&#x000A;  <span class="ruby-identifier">attr_reader</span> <span class="ruby-value">:prefix</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">pr</span>)&#x000A;    <span class="ruby-ivar">@prefix</span> = <span class="ruby-identifier">pr</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">update</span>(<span class="ruby-identifier">transmission</span>)&#x000A;    <span class="ruby-identifier">str</span> = <span class="ruby-node">&quot;Transmission received for #{prefix},&quot;</span>&#x000A;    <span class="ruby-identifier">str</span> <span class="ruby-operator">+=</span> <span class="ruby-node">&quot; length: #{transmission.length}&quot;</span>&#x000A;&#x000A;    <span class="ruby-identifier">puts</span> <span class="ruby-identifier">str</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">w1</span> = <span class="ruby-constant">Watcher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Alpha&#39;</span>)&#x000A;&#x000A;<span class="ruby-comment"># Any object with a defined #update method has transmissions sent to it</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">continuous_scan</span>(<span class="ruby-value">observe_transmissions:</span> <span class="ruby-identifier">w1</span>)&#x000A;&#x000A;<span class="ruby-comment"># You can pass one or more observers and they will all be sent updates.</span>&#x000A;<span class="ruby-comment"># Any Method object can be a observer, which will receive the transmission</span>&#x000A;&#x000A;<span class="ruby-identifier">ot</span> = [&#x000A;  <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">t</span><span class="ruby-operator">|</span> <span class="ruby-ivar">@last</span> = <span class="ruby-identifier">t</span> }.<span class="ruby-identifier">method</span>(<span class="ruby-value">:call</span>),&#x000A;  <span class="ruby-constant">Watcher</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;Beta&#39;</span>)&#x000A;]&#x000A;&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">continuous_scan</span>(<span class="ruby-value">observe_transmissions:</span> <span class="ruby-identifier">ot</span>)&#x000A;&#x000A;<span class="ruby-comment"># Pausing the scan will retain the observers, but not poll for transmissions</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">pause_scan</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">scanning?</span> <span class="ruby-comment"># =&gt; false</span>&#x000A;&#x000A;<span class="ruby-comment"># Paused scans can be resumed, and their observers start up again</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">resume_scan</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">scanning?</span> <span class="ruby-comment"># =&gt; true</span>&#x000A;&#x000A;<span class="ruby-comment"># Stopping the scan clears the observers</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">stop_scan</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">scanning?</span> <span class="ruby-comment"># =&gt; nil</span>&#x000A;&#x000A;<span class="ruby-comment"># You can also respond to codes instead of raw transmissions, by passing</span>&#x000A;<span class="ruby-comment"># in a codex to handle them or using the default codex</span>&#x000A;&#x000A;<span class="ruby-identifier">seen</span> = []&#x000A;&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Reader</span>.<span class="ruby-identifier">continuous_scan</span>(&#x000A;  <span class="ruby-value">observe_codes:</span> [<span class="ruby-identifier">seen</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:&lt;&lt;</span>), <span class="ruby-constant">Kernel</span>.<span class="ruby-identifier">method</span>(<span class="ruby-value">:puts</span>)],&#x000A;  <span class="ruby-value">codex:</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">autoload</span>.<span class="ruby-identifier">last</span>&#x000A;)&#x000A;&#x000A;<span class="ruby-identifier">seen</span> <span class="ruby-comment"># =&gt; [:volume_up, :volume_up, :prev_channel]</span></pre>

<h3 id="label-Blaster">Blaster<span><a href="#label-Blaster">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The <code>Blaster</code> class handles sending out IR data from the LED,
and handles codexes and transmissions as data sources.</p>

<pre class="ruby"><span class="ruby-identifier">tr</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Transmission</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">data:</span> <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">10</span>, <span class="ruby-value">500</span>))&#x000A;&#x000A;<span class="ruby-comment"># Directly send a transmission</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">transmit</span>(<span class="ruby-identifier">tr</span>)&#x000A;&#x000A;<span class="ruby-comment"># Or send a code from a codex</span>&#x000A;<span class="ruby-identifier">cx</span> = <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Codex</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">codes:</span> { <span class="ruby-value">power:</span> <span class="ruby-value">16575</span> }, <span class="ruby-value">protocol:</span> <span class="ruby-operator">...</span>)&#x000A;&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">send_code</span>(<span class="ruby-value">:power</span>, <span class="ruby-value">codex:</span> <span class="ruby-identifier">cx</span>)&#x000A;&#x000A;<span class="ruby-comment"># Without a codex argmument, attempts to use the default codex</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">send_code</span>(<span class="ruby-value">:power</span>)&#x000A;&#x000A;<span class="ruby-comment"># Also handles basic on, off and checking functions</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">turn_on?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">on?</span> <span class="ruby-comment"># =&gt; true</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">turn_off?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">off?</span> <span class="ruby-comment"># =&gt; true</span></pre>

<h3 id="label-Buttons">Buttons<span><a href="#label-Buttons">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Reading from the two physical buttons on the HAT is done with the
<code>Buttons</code> class.</p>

<pre class="ruby"><span class="ruby-comment"># Basic input from buttons. With no argument, blocks until you press</span>&#x000A;<span class="ruby-comment"># a button then returns an index</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">get_input</span> &#x000A;<span class="ruby-comment"># =&gt; 0</span>&#x000A;&#x000A;<span class="ruby-comment"># With arguments for seconds, it will timeout if no button is pressed</span>&#x000A;<span class="ruby-constant">Inkblot</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">get_input</span>(<span class="ruby-value">seconds:</span> <span class="ruby-value">10</span>) &#x000A;<span class="ruby-comment"># =&gt; nil if no button is pressed for 10 seconds</span>&#x000A;&#x000A;<span class="ruby-comment"># It&#39;s also possible to get chords instead of single presses</span>&#x000A;<span class="ruby-constant">Inkblot</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">get_chord_input</span>(<span class="ruby-value">count:</span> <span class="ruby-value">2</span>, <span class="ruby-value">seconds:</span> <span class="ruby-value">5</span>) &#x000A;<span class="ruby-comment"># =&gt; [0, 1] or nil if none pressed in 5s</span>&#x000A;&#x000A;<span class="ruby-comment"># Returning multiple distinct presses in a row</span>&#x000A;<span class="ruby-constant">Inkblot</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">get_multi_input</span>(<span class="ruby-value">count:</span> <span class="ruby-value">5</span>) &#x000A;<span class="ruby-comment"># =&gt; [0, 1, 1, 1, 0]</span>&#x000A;&#x000A;<span class="ruby-comment"># You can also record all button activity within a timeframe</span>&#x000A;<span class="ruby-constant">Inkblot</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">get_raw_input</span>(<span class="ruby-value">samples:</span> <span class="ruby-value">2000</span>, <span class="ruby-value">seconds:</span> <span class="ruby-value">10</span>) &#x000A;<span class="ruby-comment"># =&gt; [[0], [0, 1]...]</span></pre>

<p>It&#39;s also possible to supply callback functions to the buttons to be
run when they&#39;re pressed</p>

<pre class="ruby"><span class="ruby-comment"># Callback will run every time button is released after being pressed</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">start_callback</span>(<span class="ruby-value">0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">tick</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">pin</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">puts</span> <span class="ruby-string">&#39;Button 1 Pressed!&#39;</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-comment"># For simple one liners, you can also use this syntax</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>[<span class="ruby-value">0</span>] = <span class="ruby-operator">-&gt;</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">a</span>) { <span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Blaster</span>.<span class="ruby-identifier">send_code</span>(<span class="ruby-value">:power</span>) }&#x000A;&#x000A;<span class="ruby-comment"># To stop a callback, run stop_callback</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">stop_callback</span>(<span class="ruby-value">0</span>)&#x000A;&#x000A;<span class="ruby-comment"># Callback functions are stored, so you can resume a callback with</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">resume_callback</span>(<span class="ruby-value">0</span>)&#x000A;&#x000A;<span class="ruby-comment"># And remove a callback entirely with</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>.<span class="ruby-identifier">remove_callback</span>(<span class="ruby-value">0</span>)&#x000A;&#x000A;<span class="ruby-comment"># You can also stop and remove a callback with #[]= and nil</span>&#x000A;<span class="ruby-constant">LilBlaster</span><span class="ruby-operator">::</span><span class="ruby-constant">Buttons</span>[<span class="ruby-value">0</span>] = <span class="ruby-keyword">nil</span></pre>

<h3 id="label-Configuration">Configuration<span><a href="#label-Configuration">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>In case you want to use the gem with a different IR shield, or a custom
wiring setup, there are module level attribute accessors which let you
change the pinout. Also on the module is a function to identify the host
OS.</p>

<pre class="ruby"><span class="ruby-comment"># Switches depending on the platform</span>&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">host_os</span> <span class="ruby-comment"># =&gt; :windows / :mac / :linux / :raspberrypi</span>&#x000A;&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">transmitter_pin</span> <span class="ruby-comment"># =&gt; defaults to 17</span>&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">transmitter_pin</span> = <span class="ruby-value">23</span>&#x000A;&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">reader_pin</span> <span class="ruby-comment"># =&gt; defaults to 18</span>&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">reader_pin</span> = <span class="ruby-value">24</span>&#x000A;&#x000A;<span class="ruby-comment"># Adding more button pins will register more indexes on the Buttons class</span>&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">button_pins</span> <span class="ruby-comment"># =&gt; defaults to [27, 22]</span>&#x000A;<span class="ruby-constant">LilBlaster</span>.<span class="ruby-identifier">button_pins</span> = [<span class="ruby-value">27</span>, <span class="ruby-value">22</span>, <span class="ruby-value">28</span>, <span class="ruby-value">29</span>]</pre>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
